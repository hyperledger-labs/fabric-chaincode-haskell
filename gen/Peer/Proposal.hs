{-# LANGUAGE DeriveGeneric     #-}
{-# LANGUAGE DeriveAnyClass    #-}
{-# LANGUAGE DataKinds         #-}
{-# LANGUAGE GADTs             #-}
{-# LANGUAGE TypeApplications  #-}
{-# LANGUAGE OverloadedStrings #-}
{-# OPTIONS_GHC -fno-warn-unused-imports #-}
{-# OPTIONS_GHC -fno-warn-name-shadowing #-}
{-# OPTIONS_GHC -fno-warn-unused-matches #-}

-- | Generated by Haskell protocol buffer compiler. DO NOT EDIT!
module Peer.Proposal where
import qualified Prelude as Hs
import qualified Proto3.Suite.Class as HsProtobuf
import qualified Proto3.Suite.DotProto as HsProtobuf
import qualified Proto3.Suite.JSONPB as HsJSONPB
import Proto3.Suite.JSONPB ((.=), (.:))
import qualified Proto3.Suite.Types as HsProtobuf
import qualified Proto3.Wire as HsProtobuf
import qualified Control.Applicative as Hs
import Control.Applicative ((<*>), (<|>), (<$>))
import qualified Control.DeepSeq as Hs
import qualified Control.Monad as Hs
import qualified Data.ByteString as Hs
import qualified Data.Coerce as Hs
import qualified Data.Int as Hs (Int16, Int32, Int64)
import qualified Data.List.NonEmpty as Hs (NonEmpty(..))
import qualified Data.Map as Hs (Map, mapKeysMonotonic)
import qualified Data.Proxy as Proxy
import qualified Data.String as Hs (fromString)
import qualified Data.Text.Lazy as Hs (Text)
import qualified Data.Vector as Hs (Vector)
import qualified Data.Word as Hs (Word16, Word32, Word64)
import qualified GHC.Enum as Hs
import qualified GHC.Generics as Hs
import qualified Unsafe.Coerce as Hs
import qualified Peer.Chaincode
import qualified Peer.ProposalResponse
 
data SignedProposal = SignedProposal{signedProposalProposalBytes ::
                                     Hs.ByteString,
                                     signedProposalSignature :: Hs.ByteString}
                    deriving (Hs.Show, Hs.Eq, Hs.Ord, Hs.Generic, Hs.NFData)
 
instance HsProtobuf.Named SignedProposal where
        nameOf _ = (Hs.fromString "SignedProposal")
 
instance HsProtobuf.HasDefault SignedProposal
 
instance HsProtobuf.Message SignedProposal where
        encodeMessage _
          SignedProposal{signedProposalProposalBytes =
                           signedProposalProposalBytes,
                         signedProposalSignature = signedProposalSignature}
          = (Hs.mconcat
               [(HsProtobuf.encodeMessageField (HsProtobuf.FieldNumber 1)
                   signedProposalProposalBytes),
                (HsProtobuf.encodeMessageField (HsProtobuf.FieldNumber 2)
                   signedProposalSignature)])
        decodeMessage _
          = (Hs.pure SignedProposal) <*>
              (HsProtobuf.at HsProtobuf.decodeMessageField
                 (HsProtobuf.FieldNumber 1))
              <*>
              (HsProtobuf.at HsProtobuf.decodeMessageField
                 (HsProtobuf.FieldNumber 2))
        dotProto _
          = [(HsProtobuf.DotProtoField (HsProtobuf.FieldNumber 1)
                (HsProtobuf.Prim HsProtobuf.Bytes)
                (HsProtobuf.Single "proposal_bytes")
                []
                ""),
             (HsProtobuf.DotProtoField (HsProtobuf.FieldNumber 2)
                (HsProtobuf.Prim HsProtobuf.Bytes)
                (HsProtobuf.Single "signature")
                []
                "")]
 
instance HsJSONPB.ToJSONPB SignedProposal where
        toJSONPB (SignedProposal f1 f2)
          = (HsJSONPB.object ["proposal_bytes" .= f1, "signature" .= f2])
        toEncodingPB (SignedProposal f1 f2)
          = (HsJSONPB.pairs ["proposal_bytes" .= f1, "signature" .= f2])
 
instance HsJSONPB.FromJSONPB SignedProposal where
        parseJSONPB
          = (HsJSONPB.withObject "SignedProposal"
               (\ obj ->
                  (Hs.pure SignedProposal) <*> obj .: "proposal_bytes" <*>
                    obj .: "signature"))
 
instance HsJSONPB.ToJSON SignedProposal where
        toJSON = HsJSONPB.toAesonValue
        toEncoding = HsJSONPB.toAesonEncoding
 
instance HsJSONPB.FromJSON SignedProposal where
        parseJSON = HsJSONPB.parseJSONPB
 
instance HsJSONPB.ToSchema SignedProposal where
        declareNamedSchema _
          = do let declare_proposal_bytes = HsJSONPB.declareSchemaRef
               signedProposalProposalBytes <- declare_proposal_bytes Proxy.Proxy
               let declare_signature = HsJSONPB.declareSchemaRef
               signedProposalSignature <- declare_signature Proxy.Proxy
               let _ = Hs.pure SignedProposal <*>
                         HsJSONPB.asProxy declare_proposal_bytes
                         <*> HsJSONPB.asProxy declare_signature
               Hs.return
                 (HsJSONPB.NamedSchema{HsJSONPB._namedSchemaName =
                                         Hs.Just "SignedProposal",
                                       HsJSONPB._namedSchemaSchema =
                                         Hs.mempty{HsJSONPB._schemaParamSchema =
                                                     Hs.mempty{HsJSONPB._paramSchemaType =
                                                                 HsJSONPB.SwaggerObject},
                                                   HsJSONPB._schemaProperties =
                                                     HsJSONPB.insOrdFromList
                                                       [("proposal_bytes",
                                                         signedProposalProposalBytes),
                                                        ("signature", signedProposalSignature)]}})
 
data Proposal = Proposal{proposalHeader :: Hs.ByteString,
                         proposalPayload :: Hs.ByteString,
                         proposalExtension :: Hs.ByteString}
              deriving (Hs.Show, Hs.Eq, Hs.Ord, Hs.Generic, Hs.NFData)
 
instance HsProtobuf.Named Proposal where
        nameOf _ = (Hs.fromString "Proposal")
 
instance HsProtobuf.HasDefault Proposal
 
instance HsProtobuf.Message Proposal where
        encodeMessage _
          Proposal{proposalHeader = proposalHeader,
                   proposalPayload = proposalPayload,
                   proposalExtension = proposalExtension}
          = (Hs.mconcat
               [(HsProtobuf.encodeMessageField (HsProtobuf.FieldNumber 1)
                   proposalHeader),
                (HsProtobuf.encodeMessageField (HsProtobuf.FieldNumber 2)
                   proposalPayload),
                (HsProtobuf.encodeMessageField (HsProtobuf.FieldNumber 3)
                   proposalExtension)])
        decodeMessage _
          = (Hs.pure Proposal) <*>
              (HsProtobuf.at HsProtobuf.decodeMessageField
                 (HsProtobuf.FieldNumber 1))
              <*>
              (HsProtobuf.at HsProtobuf.decodeMessageField
                 (HsProtobuf.FieldNumber 2))
              <*>
              (HsProtobuf.at HsProtobuf.decodeMessageField
                 (HsProtobuf.FieldNumber 3))
        dotProto _
          = [(HsProtobuf.DotProtoField (HsProtobuf.FieldNumber 1)
                (HsProtobuf.Prim HsProtobuf.Bytes)
                (HsProtobuf.Single "header")
                []
                ""),
             (HsProtobuf.DotProtoField (HsProtobuf.FieldNumber 2)
                (HsProtobuf.Prim HsProtobuf.Bytes)
                (HsProtobuf.Single "payload")
                []
                ""),
             (HsProtobuf.DotProtoField (HsProtobuf.FieldNumber 3)
                (HsProtobuf.Prim HsProtobuf.Bytes)
                (HsProtobuf.Single "extension")
                []
                "")]
 
instance HsJSONPB.ToJSONPB Proposal where
        toJSONPB (Proposal f1 f2 f3)
          = (HsJSONPB.object
               ["header" .= f1, "payload" .= f2, "extension" .= f3])
        toEncodingPB (Proposal f1 f2 f3)
          = (HsJSONPB.pairs
               ["header" .= f1, "payload" .= f2, "extension" .= f3])
 
instance HsJSONPB.FromJSONPB Proposal where
        parseJSONPB
          = (HsJSONPB.withObject "Proposal"
               (\ obj ->
                  (Hs.pure Proposal) <*> obj .: "header" <*> obj .: "payload" <*>
                    obj .: "extension"))
 
instance HsJSONPB.ToJSON Proposal where
        toJSON = HsJSONPB.toAesonValue
        toEncoding = HsJSONPB.toAesonEncoding
 
instance HsJSONPB.FromJSON Proposal where
        parseJSON = HsJSONPB.parseJSONPB
 
instance HsJSONPB.ToSchema Proposal where
        declareNamedSchema _
          = do let declare_header = HsJSONPB.declareSchemaRef
               proposalHeader <- declare_header Proxy.Proxy
               let declare_payload = HsJSONPB.declareSchemaRef
               proposalPayload <- declare_payload Proxy.Proxy
               let declare_extension = HsJSONPB.declareSchemaRef
               proposalExtension <- declare_extension Proxy.Proxy
               let _ = Hs.pure Proposal <*> HsJSONPB.asProxy declare_header <*>
                         HsJSONPB.asProxy declare_payload
                         <*> HsJSONPB.asProxy declare_extension
               Hs.return
                 (HsJSONPB.NamedSchema{HsJSONPB._namedSchemaName =
                                         Hs.Just "Proposal",
                                       HsJSONPB._namedSchemaSchema =
                                         Hs.mempty{HsJSONPB._schemaParamSchema =
                                                     Hs.mempty{HsJSONPB._paramSchemaType =
                                                                 HsJSONPB.SwaggerObject},
                                                   HsJSONPB._schemaProperties =
                                                     HsJSONPB.insOrdFromList
                                                       [("header", proposalHeader),
                                                        ("payload", proposalPayload),
                                                        ("extension", proposalExtension)]}})
 
data ChaincodeHeaderExtension = ChaincodeHeaderExtension{chaincodeHeaderExtensionChaincodeId
                                                         :: Hs.Maybe Peer.Chaincode.ChaincodeID}
                              deriving (Hs.Show, Hs.Eq, Hs.Ord, Hs.Generic, Hs.NFData)
 
instance HsProtobuf.Named ChaincodeHeaderExtension where
        nameOf _ = (Hs.fromString "ChaincodeHeaderExtension")
 
instance HsProtobuf.HasDefault ChaincodeHeaderExtension
 
instance HsProtobuf.Message ChaincodeHeaderExtension where
        encodeMessage _
          ChaincodeHeaderExtension{chaincodeHeaderExtensionChaincodeId =
                                     chaincodeHeaderExtensionChaincodeId}
          = (Hs.mconcat
               [(HsProtobuf.encodeMessageField (HsProtobuf.FieldNumber 2)
                   (Hs.coerce @(Hs.Maybe Peer.Chaincode.ChaincodeID)
                      @(HsProtobuf.Nested Peer.Chaincode.ChaincodeID)
                      chaincodeHeaderExtensionChaincodeId))])
        decodeMessage _
          = (Hs.pure ChaincodeHeaderExtension) <*>
              (Hs.coerce @(_ (HsProtobuf.Nested Peer.Chaincode.ChaincodeID))
                 @(_ (Hs.Maybe Peer.Chaincode.ChaincodeID))
                 (HsProtobuf.at HsProtobuf.decodeMessageField
                    (HsProtobuf.FieldNumber 2)))
        dotProto _
          = [(HsProtobuf.DotProtoField (HsProtobuf.FieldNumber 2)
                (HsProtobuf.Prim
                   (HsProtobuf.Named (HsProtobuf.Single "ChaincodeID")))
                (HsProtobuf.Single "chaincode_id")
                []
                "")]
 
instance HsJSONPB.ToJSONPB ChaincodeHeaderExtension where
        toJSONPB (ChaincodeHeaderExtension f2)
          = (HsJSONPB.object ["chaincode_id" .= f2])
        toEncodingPB (ChaincodeHeaderExtension f2)
          = (HsJSONPB.pairs ["chaincode_id" .= f2])
 
instance HsJSONPB.FromJSONPB ChaincodeHeaderExtension where
        parseJSONPB
          = (HsJSONPB.withObject "ChaincodeHeaderExtension"
               (\ obj ->
                  (Hs.pure ChaincodeHeaderExtension) <*> obj .: "chaincode_id"))
 
instance HsJSONPB.ToJSON ChaincodeHeaderExtension where
        toJSON = HsJSONPB.toAesonValue
        toEncoding = HsJSONPB.toAesonEncoding
 
instance HsJSONPB.FromJSON ChaincodeHeaderExtension where
        parseJSON = HsJSONPB.parseJSONPB
 
instance HsJSONPB.ToSchema ChaincodeHeaderExtension where
        declareNamedSchema _
          = do let declare_chaincode_id = HsJSONPB.declareSchemaRef
               chaincodeHeaderExtensionChaincodeId <- declare_chaincode_id
                                                        Proxy.Proxy
               let _ = Hs.pure ChaincodeHeaderExtension <*>
                         HsJSONPB.asProxy declare_chaincode_id
               Hs.return
                 (HsJSONPB.NamedSchema{HsJSONPB._namedSchemaName =
                                         Hs.Just "ChaincodeHeaderExtension",
                                       HsJSONPB._namedSchemaSchema =
                                         Hs.mempty{HsJSONPB._schemaParamSchema =
                                                     Hs.mempty{HsJSONPB._paramSchemaType =
                                                                 HsJSONPB.SwaggerObject},
                                                   HsJSONPB._schemaProperties =
                                                     HsJSONPB.insOrdFromList
                                                       [("chaincode_id",
                                                         chaincodeHeaderExtensionChaincodeId)]}})
 
data ChaincodeProposalPayload = ChaincodeProposalPayload{chaincodeProposalPayloadInput
                                                         :: Hs.ByteString,
                                                         chaincodeProposalPayloadTransientMap ::
                                                         Hs.Map Hs.Text Hs.ByteString}
                              deriving (Hs.Show, Hs.Eq, Hs.Ord, Hs.Generic, Hs.NFData)
 
instance HsProtobuf.Named ChaincodeProposalPayload where
        nameOf _ = (Hs.fromString "ChaincodeProposalPayload")
 
instance HsProtobuf.HasDefault ChaincodeProposalPayload
 
instance HsProtobuf.Message ChaincodeProposalPayload where
        encodeMessage _
          ChaincodeProposalPayload{chaincodeProposalPayloadInput =
                                     chaincodeProposalPayloadInput,
                                   chaincodeProposalPayloadTransientMap =
                                     chaincodeProposalPayloadTransientMap}
          = (Hs.mconcat
               [(HsProtobuf.encodeMessageField (HsProtobuf.FieldNumber 1)
                   chaincodeProposalPayloadInput),
                (HsProtobuf.encodeMessageField (HsProtobuf.FieldNumber 2)
                   chaincodeProposalPayloadTransientMap)])
        decodeMessage _
          = (Hs.pure ChaincodeProposalPayload) <*>
              (HsProtobuf.at HsProtobuf.decodeMessageField
                 (HsProtobuf.FieldNumber 1))
              <*>
              (HsProtobuf.at HsProtobuf.decodeMessageField
                 (HsProtobuf.FieldNumber 2))
        dotProto _
          = [(HsProtobuf.DotProtoField (HsProtobuf.FieldNumber 1)
                (HsProtobuf.Prim HsProtobuf.Bytes)
                (HsProtobuf.Single "input")
                []
                ""),
             (HsProtobuf.DotProtoField (HsProtobuf.FieldNumber 2)
                (HsProtobuf.Map HsProtobuf.String HsProtobuf.Bytes)
                (HsProtobuf.Single "TransientMap")
                []
                "")]
 
instance HsJSONPB.ToJSONPB ChaincodeProposalPayload where
        toJSONPB (ChaincodeProposalPayload f1 f2)
          = (HsJSONPB.object ["input" .= f1, "TransientMap" .= f2])
        toEncodingPB (ChaincodeProposalPayload f1 f2)
          = (HsJSONPB.pairs ["input" .= f1, "TransientMap" .= f2])
 
instance HsJSONPB.FromJSONPB ChaincodeProposalPayload where
        parseJSONPB
          = (HsJSONPB.withObject "ChaincodeProposalPayload"
               (\ obj ->
                  (Hs.pure ChaincodeProposalPayload) <*> obj .: "input" <*>
                    obj .: "TransientMap"))
 
instance HsJSONPB.ToJSON ChaincodeProposalPayload where
        toJSON = HsJSONPB.toAesonValue
        toEncoding = HsJSONPB.toAesonEncoding
 
instance HsJSONPB.FromJSON ChaincodeProposalPayload where
        parseJSON = HsJSONPB.parseJSONPB
 
instance HsJSONPB.ToSchema ChaincodeProposalPayload where
        declareNamedSchema _
          = do let declare_input = HsJSONPB.declareSchemaRef
               chaincodeProposalPayloadInput <- declare_input Proxy.Proxy
               let declare_TransientMap = HsJSONPB.declareSchemaRef
               chaincodeProposalPayloadTransientMap <- declare_TransientMap
                                                         Proxy.Proxy
               let _ = Hs.pure ChaincodeProposalPayload <*>
                         HsJSONPB.asProxy declare_input
                         <*> HsJSONPB.asProxy declare_TransientMap
               Hs.return
                 (HsJSONPB.NamedSchema{HsJSONPB._namedSchemaName =
                                         Hs.Just "ChaincodeProposalPayload",
                                       HsJSONPB._namedSchemaSchema =
                                         Hs.mempty{HsJSONPB._schemaParamSchema =
                                                     Hs.mempty{HsJSONPB._paramSchemaType =
                                                                 HsJSONPB.SwaggerObject},
                                                   HsJSONPB._schemaProperties =
                                                     HsJSONPB.insOrdFromList
                                                       [("input", chaincodeProposalPayloadInput),
                                                        ("TransientMap",
                                                         chaincodeProposalPayloadTransientMap)]}})
 
data ChaincodeAction = ChaincodeAction{chaincodeActionResults ::
                                       Hs.ByteString,
                                       chaincodeActionEvents :: Hs.ByteString,
                                       chaincodeActionResponse ::
                                       Hs.Maybe Peer.ProposalResponse.Response,
                                       chaincodeActionChaincodeId ::
                                       Hs.Maybe Peer.Chaincode.ChaincodeID}
                     deriving (Hs.Show, Hs.Eq, Hs.Ord, Hs.Generic, Hs.NFData)
 
instance HsProtobuf.Named ChaincodeAction where
        nameOf _ = (Hs.fromString "ChaincodeAction")
 
instance HsProtobuf.HasDefault ChaincodeAction
 
instance HsProtobuf.Message ChaincodeAction where
        encodeMessage _
          ChaincodeAction{chaincodeActionResults = chaincodeActionResults,
                          chaincodeActionEvents = chaincodeActionEvents,
                          chaincodeActionResponse = chaincodeActionResponse,
                          chaincodeActionChaincodeId = chaincodeActionChaincodeId}
          = (Hs.mconcat
               [(HsProtobuf.encodeMessageField (HsProtobuf.FieldNumber 1)
                   chaincodeActionResults),
                (HsProtobuf.encodeMessageField (HsProtobuf.FieldNumber 2)
                   chaincodeActionEvents),
                (HsProtobuf.encodeMessageField (HsProtobuf.FieldNumber 3)
                   (Hs.coerce @(Hs.Maybe Peer.ProposalResponse.Response)
                      @(HsProtobuf.Nested Peer.ProposalResponse.Response)
                      chaincodeActionResponse)),
                (HsProtobuf.encodeMessageField (HsProtobuf.FieldNumber 4)
                   (Hs.coerce @(Hs.Maybe Peer.Chaincode.ChaincodeID)
                      @(HsProtobuf.Nested Peer.Chaincode.ChaincodeID)
                      chaincodeActionChaincodeId))])
        decodeMessage _
          = (Hs.pure ChaincodeAction) <*>
              (HsProtobuf.at HsProtobuf.decodeMessageField
                 (HsProtobuf.FieldNumber 1))
              <*>
              (HsProtobuf.at HsProtobuf.decodeMessageField
                 (HsProtobuf.FieldNumber 2))
              <*>
              (Hs.coerce @(_ (HsProtobuf.Nested Peer.ProposalResponse.Response))
                 @(_ (Hs.Maybe Peer.ProposalResponse.Response))
                 (HsProtobuf.at HsProtobuf.decodeMessageField
                    (HsProtobuf.FieldNumber 3)))
              <*>
              (Hs.coerce @(_ (HsProtobuf.Nested Peer.Chaincode.ChaincodeID))
                 @(_ (Hs.Maybe Peer.Chaincode.ChaincodeID))
                 (HsProtobuf.at HsProtobuf.decodeMessageField
                    (HsProtobuf.FieldNumber 4)))
        dotProto _
          = [(HsProtobuf.DotProtoField (HsProtobuf.FieldNumber 1)
                (HsProtobuf.Prim HsProtobuf.Bytes)
                (HsProtobuf.Single "results")
                []
                ""),
             (HsProtobuf.DotProtoField (HsProtobuf.FieldNumber 2)
                (HsProtobuf.Prim HsProtobuf.Bytes)
                (HsProtobuf.Single "events")
                []
                ""),
             (HsProtobuf.DotProtoField (HsProtobuf.FieldNumber 3)
                (HsProtobuf.Prim (HsProtobuf.Named (HsProtobuf.Single "Response")))
                (HsProtobuf.Single "response")
                []
                ""),
             (HsProtobuf.DotProtoField (HsProtobuf.FieldNumber 4)
                (HsProtobuf.Prim
                   (HsProtobuf.Named (HsProtobuf.Single "ChaincodeID")))
                (HsProtobuf.Single "chaincode_id")
                []
                "")]
 
instance HsJSONPB.ToJSONPB ChaincodeAction where
        toJSONPB (ChaincodeAction f1 f2 f3 f4)
          = (HsJSONPB.object
               ["results" .= f1, "events" .= f2, "response" .= f3,
                "chaincode_id" .= f4])
        toEncodingPB (ChaincodeAction f1 f2 f3 f4)
          = (HsJSONPB.pairs
               ["results" .= f1, "events" .= f2, "response" .= f3,
                "chaincode_id" .= f4])
 
instance HsJSONPB.FromJSONPB ChaincodeAction where
        parseJSONPB
          = (HsJSONPB.withObject "ChaincodeAction"
               (\ obj ->
                  (Hs.pure ChaincodeAction) <*> obj .: "results" <*> obj .: "events"
                    <*> obj .: "response"
                    <*> obj .: "chaincode_id"))
 
instance HsJSONPB.ToJSON ChaincodeAction where
        toJSON = HsJSONPB.toAesonValue
        toEncoding = HsJSONPB.toAesonEncoding
 
instance HsJSONPB.FromJSON ChaincodeAction where
        parseJSON = HsJSONPB.parseJSONPB
 
instance HsJSONPB.ToSchema ChaincodeAction where
        declareNamedSchema _
          = do let declare_results = HsJSONPB.declareSchemaRef
               chaincodeActionResults <- declare_results Proxy.Proxy
               let declare_events = HsJSONPB.declareSchemaRef
               chaincodeActionEvents <- declare_events Proxy.Proxy
               let declare_response = HsJSONPB.declareSchemaRef
               chaincodeActionResponse <- declare_response Proxy.Proxy
               let declare_chaincode_id = HsJSONPB.declareSchemaRef
               chaincodeActionChaincodeId <- declare_chaincode_id Proxy.Proxy
               let _ = Hs.pure ChaincodeAction <*>
                         HsJSONPB.asProxy declare_results
                         <*> HsJSONPB.asProxy declare_events
                         <*> HsJSONPB.asProxy declare_response
                         <*> HsJSONPB.asProxy declare_chaincode_id
               Hs.return
                 (HsJSONPB.NamedSchema{HsJSONPB._namedSchemaName =
                                         Hs.Just "ChaincodeAction",
                                       HsJSONPB._namedSchemaSchema =
                                         Hs.mempty{HsJSONPB._schemaParamSchema =
                                                     Hs.mempty{HsJSONPB._paramSchemaType =
                                                                 HsJSONPB.SwaggerObject},
                                                   HsJSONPB._schemaProperties =
                                                     HsJSONPB.insOrdFromList
                                                       [("results", chaincodeActionResults),
                                                        ("events", chaincodeActionEvents),
                                                        ("response", chaincodeActionResponse),
                                                        ("chaincode_id",
                                                         chaincodeActionChaincodeId)]}})